<!DOCTYPE html><html><head><link rel="stylesheet" href="assets/main.css"><script language="javascript" type="text/javascript" src="libraries/p5.js"></script><script language="javascript" type="text/javascript" src="libraries/p5.dom.js"></script></head><body><h1>through2</h1><p><a href="http://travis-ci.org/rvagg/through2"><img src="https://secure.travis-ci.org/rvagg/through2.png" alt="Build Status"></a></p>
<p><a href="https://nodei.co/npm/through2/"><img src="https://nodei.co/npm/through2.png?compact=true" alt="NPM"></a> </p>
<p><a href="https://david-dm.org/rvagg/through2/"><img src="https://david-dm.org/rvagg/through2.png" alt="david-dm"></a>
<a href="https://david-dm.org/rvagg/through2#info=devDependencies/"><img src="https://david-dm.org/rvagg/through2/dev-status.png" alt="david-dm"></a></p>
<p><strong>A tiny wrapper around Node streams.Transform (Streams2) to avoid explicit subclassing noise</strong></p>
<p>Inspired by <a href="https://github.com/dominictarr">Dominic Tarr</a>&#39;s <a href="https://github.com/dominictarr/through">through</a> in that it&#39;s so much easier to make a stream out of a function than it is to set up the prototype chain properly: <code>through(function (chunk) { ... })</code>.</p>
<pre><code class="language-js">fs.createReadStream(&#39;ex.txt&#39;)
    .pipe(through2(function (chunk, enc, callback) {
    for (var i = 0; i &lt; chunk.length; i++)
      if (chunk[i] == 97)
        chunk[i] = 122 // swap &#39;a&#39; for &#39;z&#39;
    this.push(chunk)
    callback()
  }))
  .pipe(fs.createWriteStream(&#39;out.txt&#39;))
</code></pre>
<p>Or object streams:</p>
<pre><code class="language-js">var all = []
fs.createReadStream(&#39;data.csv&#39;)
  .pipe(csv2())
  .pipe(through2({ objectMode: true }, function (chunk, enc, callback) {
      var data = {
        name    : chunk[0]
      , address : chunk[3]
      , phone   : chunk[10]
    }
    this.push(data)
    callback()
  }))
  .on(&#39;data&#39;, function (data) {
    all.push(data)
  })
  .on(&#39;end&#39;, function () {
    doSomethingSpecial(all)
  })
</code></pre>
<h2>API</h2><p><b><code>through2([ options, ] [ transformFunction ] [, flushFunction ])</code></b></p>
<p>Consult the <strong><a href="http://nodejs.org/docs/latest/api/stream.html#stream_class_stream_transform">stream.Transform</a></strong> documentation for the exact rules of the <code>transformFunction</code> (i.e. <code>this._transform</code>) and the optional <code>flushFunction</code> (i.e. <code>this._flush</code>).</p>
<h3>options</h3><p>The options argument is optional and is passed straight through to <code>stream.Transform</code>. So you can use <code>objectMode:true</code> if you are processing non-binary streams.</p>
<p>The <code>options</code> argument is first, unlike standard convention, because if I&#39;m passing in an anonymous function then I&#39;d prefer for the options argument to not get lost at the end of the call:</p>
<pre><code class="language-js">fs.createReadStream(&#39;/tmp/important.dat&#39;)
    .pipe(through2({ objectMode: true, allowHalfOpen: false }, function (chunk, enc, cb) {
        this.push(new Buffer(&#39;wut?&#39;))
      cb()
    })
  .pipe(fs.createWriteStream(&#39;/tmp/wut.txt&#39;))
</code></pre>
<h3>transformFunction</h3><p>The <code>transformFunction</code> must have the following signature: <code>function (chunk, encoding, callback) {}</code>. A minimal implementation should call the <code>callback</code> function to indicate that the transformation is done, even if that transformation means discarding the chunk.</p>
<p>To queue a new chunk, call <code>this.push(chunk)</code>&mdash;this can be called as many times as required before the <code>callback()</code> if you have multiple pieces to send on.</p>
<p>If you <strong>do not provide a <code>transformFunction</code></strong> then you will get a simple simple pass-through stream.</p>
<h3>flushFunction</h3><p>The optional <code>flushFunction</code> is provided as the last argument (2nd or 3rd, depending on whether you&#39;ve supplied options) is called just prior to the stream ending. Can be used to finish up any processing that may be in progress.</p>
<p><b><code>through2.ctor([ options, ] transformFunction[, flushFunction ])</code></b></p>
<p>Instead of returning a <code>stream.Transform</code> instance, <code>through2.ctor()</code> returns a <strong>constructor</strong> for a custom Transform. This is useful when you want to use the same transform logic in multiple instances.</p>
<pre><code class="language-js">var FToC = through2.ctor({objectMode: true}, function (record, encoding, callback) {
  if (record.temp != null &amp;&amp; record.unit = &quot;F&quot;) {
    record.temp = ( ( record.temp - 32 ) * 5 ) / 9
    record.unit = &quot;C&quot;
  }
  this.push(record)
  callback()
})

// Create instances of FToC like so:
var converter = new FToC()
// Or:
var converter = FToC()
// Or specify/override options when you instantiate, if you prefer:
var converter = FToC({objectMode: true})
</code></pre>
<h2>License</h2><p><strong>through2</strong> is Copyright (c) 2013 Rod Vagg <a href="https://twitter.com/rvagg">@rvagg</a> and licenced under the MIT licence. All rights not explicitly granted in the MIT license are reserved. See the included LICENSE file for more details.</p></body></html>